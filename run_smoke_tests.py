#!/usr/bin/env python3
"""
Script completo para ejecutar smoke tests y validar que todo funciona correctamente
Valida todas las funcionalidades cr√≠ticas antes de permitir operaciones
"""

import subprocess
import sys
import os
import time
from typing import Dict, List, Tuple

class SmokeTestRunner:
    def __init__(self):
        self.test_results = {}
        self.total_tests = 0
        self.passed_tests = 0
        
    def run_command(self, command: str, description: str) -> bool:
        """Ejecutar un comando y reportar resultado"""
        print(f"\nüß™ {description}")
        print(f"   Comando: {command}")
        
        try:
            result = subprocess.run(
                command, 
                shell=True, 
                capture_output=True, 
                text=True, 
                timeout=30
            )
            
            if result.returncode == 0:
                print(f"   ‚úÖ PAS√ì - {description}")
                if result.stdout.strip():
                    print(f"      Output: {result.stdout.strip()}")
                return True
            else:
                print(f"   ‚ùå FALL√ì - {description}")
                if result.stderr.strip():
                    print(f"      Error: {result.stderr.strip()}")
                return False
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ TIMEOUT - {description}")
            return False
        except Exception as e:
            print(f"   üí• EXCEPCI√ìN - {description}: {e}")
            return False
    
    def test_database_structure(self) -> bool:
        """Test 1: Verificar estructura de base de datos"""
        print("\nüóÑÔ∏è TEST 1: Estructura de Base de Datos")
        
        # Verificar que existe la BD
        if not os.path.exists('trading_data.db'):
            print("   ‚ùå Base de datos no existe")
            return False
        
        # Verificar que se puede conectar
        test_sql = "python3 -c \"import sqlite3; conn = sqlite3.connect('trading_data.db'); print('‚úÖ BD accesible'); conn.close()\""
        return self.run_command(test_sql, "Conexi√≥n a base de datos")
    
    def test_data_coverage(self) -> bool:
        """Test 2: Verificar cobertura de datos"""
        print("\nüìä TEST 2: Cobertura de Datos")
        
        # Ejecutar script de validaci√≥n
        return self.run_command("python3 validate_data_coverage.py", "Validaci√≥n de cobertura de datos")
    
    def test_configuration_loading(self) -> bool:
        """Test 3: Verificar carga de configuraci√≥n"""
        print("\n‚öôÔ∏è TEST 3: Carga de Configuraci√≥n")
        
        test_config = """
import sys
sys.path.append('.')
from advanced_trading.config.trading_config import TRADING_CONFIG
print('‚úÖ Configuraci√≥n cargada correctamente')
print(f'‚úÖ Timezone: {TRADING_CONFIG.get("TIMEZONE_CONFIG", {}).get("PRIMARY_TIMEZONE", "NO_CONFIG")}')
print(f'‚úÖ Max Spread: {TRADING_CONFIG.get("MAX_SPREAD_BPS", "NO_CONFIG")} bps')
print(f'‚úÖ Max Slippage: {TRADING_CONFIG.get("MAX_SLIPPAGE_BPS", "NO_CONFIG")} bps')
"""
        
        with open('temp_config_test.py', 'w') as f:
            f.write(test_config)
        
        result = self.run_command("python3 temp_config_test.py", "Carga de configuraci√≥n de trading")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_config_test.py'):
            os.remove('temp_config_test.py')
        
        return result
    
    def test_risk_manager(self) -> bool:
        """Test 4: Verificar Risk Manager"""
        print("\nüõ°Ô∏è TEST 4: Risk Manager")
        
        test_risk = """
import sys
sys.path.append('.')
from advanced_trading.advanced_risk_manager import AdvancedRiskManager
rm = AdvancedRiskManager(10000)
print('‚úÖ Risk Manager cargado correctamente')
print(f'‚úÖ Risk per trade: {rm.risk_per_trade}')
"""
        
        with open('temp_risk_test.py', 'w') as f:
            f.write(test_risk)
        
        result = self.run_command("python3 temp_risk_test.py", "Risk Manager funcional")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_risk_test.py'):
            os.remove('temp_risk_test.py')
        
        return result
    
    def test_macro_analyzer(self) -> bool:
        """Test 5: Verificar Macro Analyzer"""
        print("\nüìà TEST 5: Macro Analyzer")
        
        test_macro = """
import sys
sys.path.append('.')
from advanced_trading.macro_analyzer import MacroAnalyzer
ma = MacroAnalyzer()
print('‚úÖ Macro Analyzer cargado correctamente')
"""
        
        with open('temp_macro_test.py', 'w') as f:
            f.write(test_macro)
        
        result = self.run_command("python3 temp_macro_test.py", "Macro Analyzer funcional")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_macro_test.py'):
            os.remove('temp_macro_test.py')
        
        return result
    
    def test_arbitrage_system(self) -> bool:
        """Test 6: Verificar Sistema de Arbitraje"""
        print("\n‚öñÔ∏è TEST 6: Sistema de Arbitraje")
        
        test_arb = """
import sys
sys.path.append('.')
from advanced_trading.relative_arbitrage import RelativeArbitrage
ra = RelativeArbitrage()
print('‚úÖ Relative Arbitrage cargado correctamente')
"""
        
        with open('temp_arb_test.py', 'w') as f:
            f.write(test_arb)
        
        result = self.run_command("python3 temp_arb_test.py", "Sistema de arbitraje funcional")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_arb_test.py'):
            os.remove('temp_arb_test.py')
        
        return result
    
    def test_execution_system(self) -> bool:
        """Test 7: Verificar Sistema de Ejecuci√≥n"""
        print("\nüöÄ TEST 7: Sistema de Ejecuci√≥n")
        
        test_exec = """
import sys
sys.path.append('.')
from advanced_trading.staggered_execution import StaggeredExecution
se = StaggeredExecution()
print('‚úÖ Staggered Execution cargado correctamente')
"""
        
        with open('temp_exec_test.py', 'w') as f:
            f.write(test_exec)
        
        result = self.run_command("python3 temp_exec_test.py", "Sistema de ejecuci√≥n funcional")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_exec_test.py'):
            os.remove('temp_exec_test.py')
        
        return result
    
    def test_calibration_system(self) -> bool:
        """Test 8: Verificar Sistema de Calibraci√≥n"""
        print("\nüîß TEST 8: Sistema de Calibraci√≥n")
        
        # Verificar que las configuraciones de calibraci√≥n est√°n presentes
        test_cal = """
import sys
sys.path.append('.')
from advanced_trading.config.trading_config import TRADING_CONFIG
config = TRADING_CONFIG

# Verificar configuraciones cr√≠ticas
required_configs = [
    'CALIBRATION_GUARDRAILS',
    'MANUAL_APPROVAL', 
    'SNAPSHOT_ROLLBACK',
    'EVENT_FAMILIES',
    'BACKTEST_METRICS'
]

missing = []
for req in required_configs:
    if req not in config:
        missing.append(req)

if missing:
    print(f'‚ùå Configuraciones faltantes: {missing}')
else:
    print('‚úÖ Todas las configuraciones de calibraci√≥n presentes')
    print(f'‚úÖ Max Delta per Cycle: {config["CALIBRATION_GUARDRAILS"]["MAX_DELTA_PER_CYCLE"]}')
    print(f'‚úÖ Manual Approval: {config["MANUAL_APPROVAL"]["ENABLED"]}')
    print(f'‚úÖ Snapshot System: {config["SNAPSHOT_ROLLBACK"]["ENABLED"]}')
"""
        
        with open('temp_cal_test.py', 'w') as f:
            f.write(test_cal)
        
        result = self.run_command("python3 temp_cal_test.py", "Sistema de calibraci√≥n configurado")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_cal_test.py'):
            os.remove('temp_cal_test.py')
        
        return result
    
    def test_timezone_configuration(self) -> bool:
        """Test 9: Verificar Configuraci√≥n de Timezone"""
        print("\nüïê TEST 9: Configuraci√≥n de Timezone")
        
        test_tz = """
import sys
sys.path.append('.')
from advanced_trading.config.trading_config import TRADING_CONFIG
config = TRADING_CONFIG

timezone_config = config.get('TIMEZONE_CONFIG', {})
primary_tz = timezone_config.get('PRIMARY_TIMEZONE', 'NO_CONFIG')

if primary_tz == 'America/Chicago':
    print('‚úÖ Timezone configurado correctamente en America/Chicago')
    print(f'‚úÖ Ingest: {timezone_config.get("INGEST_TIMEZONE", "NO_CONFIG")}')
    print(f'‚úÖ Scheduler: {timezone_config.get("SCHEDULER_TIMEZONE", "NO_CONFIG")}')
    print(f'‚úÖ Walk-Forward: {timezone_config.get("WALK_FORWARD_TIMEZONE", "NO_CONFIG")}')
else:
    print(f'‚ùå Timezone incorrecto: {primary_tz}')
"""
        
        with open('temp_tz_test.py', 'w') as f:
            f.write(test_tz)
        
        result = self.run_command("python3 temp_tz_test.py", "Configuraci√≥n de timezone")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_tz_test.py'):
            os.remove('temp_tz_test.py')
        
        return result
    
    def test_feature_flags(self) -> bool:
        """Test 10: Verificar Feature Flags"""
        print("\nüö© TEST 10: Feature Flags")
        
        test_flags = """
import sys
sys.path.append('.')
from advanced_trading.config.trading_config import TRADING_CONFIG
config = TRADING_CONFIG

features = config.get('FEATURES', {})
required_flags = [
    'AUTO_CALIBRATION_ON',
    'REQUIRE_MANUAL_APPROVAL',
    'ROLLBACK_ON_DEGRADATION',
    'HIST_WEIGHTING_ON',
    'BACKTEST_OPT_ON',
    'STOP_RULES_ON'
]

missing = []
for flag in required_flags:
    if flag not in features:
        missing.append(flag)

if missing:
    print(f'‚ùå Feature flags faltantes: {missing}')
else:
    print('‚úÖ Todos los feature flags presentes')
    for flag in required_flags:
        status = 'ON' if features[flag] else 'OFF'
        print(f'   {flag}: {status}')
"""
        
        with open('temp_flags_test.py', 'w') as f:
            f.write(test_flags)
        
        result = self.run_command("python3 temp_flags_test.py", "Feature flags configurados")
        
        # Limpiar archivo temporal
        if os.path.exists('temp_flags_test.py'):
            os.remove('temp_flags_test.py')
        
        return result
    
    def run_all_tests(self) -> Dict[str, bool]:
        """Ejecutar todos los smoke tests"""
        print("üöÄ INICIANDO SMOKE TESTS COMPLETOS")
        print("=" * 60)
        print("üéØ Objetivo: Validar que el sistema est√° listo para operaciones")
        print("=" * 60)
        
        # Lista de todos los tests
        tests = [
            ("Estructura de Base de Datos", self.test_database_structure),
            ("Cobertura de Datos", self.test_data_coverage),
            ("Carga de Configuraci√≥n", self.test_configuration_loading),
            ("Risk Manager", self.test_risk_manager),
            ("Macro Analyzer", self.test_macro_analyzer),
            ("Sistema de Arbitraje", self.test_arbitrage_system),
            ("Sistema de Ejecuci√≥n", self.test_execution_system),
            ("Sistema de Calibraci√≥n", self.test_calibration_system),
            ("Configuraci√≥n de Timezone", self.test_timezone_configuration),
            ("Feature Flags", self.test_feature_flags)
        ]
        
        # Ejecutar cada test
        for test_name, test_func in tests:
            self.total_tests += 1
            print(f"\n{'='*60}")
            print(f"üß™ TEST {self.total_tests}/10: {test_name}")
            print(f"{'='*60}")
            
            try:
                result = test_func()
                self.test_results[test_name] = result
                if result:
                    self.passed_tests += 1
                    print(f"   üéâ {test_name}: PAS√ì")
                else:
                    print(f"   üí• {test_name}: FALL√ì")
            except Exception as e:
                print(f"   üí• {test_name}: EXCEPCI√ìN - {e}")
                self.test_results[test_name] = False
        
        return self.test_results
    
    def generate_report(self) -> None:
        """Generar reporte final de smoke tests"""
        print(f"\n{'='*60}")
        print("üìã REPORTE FINAL DE SMOKE TESTS")
        print(f"{'='*60}")
        
        print(f"üìä Resumen:")
        print(f"   Total de tests: {self.total_tests}")
        print(f"   Tests pasados: {self.passed_tests}")
        print(f"   Tests fallidos: {self.total_tests - self.passed_tests}")
        print(f"   Tasa de √©xito: {(self.passed_tests/self.total_tests)*100:.1f}%")
        
        print(f"\nüìã Detalle por test:")
        for test_name, result in self.test_results.items():
            status = "‚úÖ PAS√ì" if result else "‚ùå FALL√ì"
            print(f"   {test_name}: {status}")
        
        print(f"\nüéØ RESULTADO FINAL:")
        if self.passed_tests == self.total_tests:
            print("   üöÄ SISTEMA LISTO PARA OPERACIONES")
            print("   ‚úÖ Todos los smoke tests pasaron")
            print("   ‚úÖ Sistema validado completamente")
            print("   ‚úÖ Puedes proceder con confianza")
        else:
            print("   ‚ö†Ô∏è SISTEMA NO LISTO PARA OPERACIONES")
            print("   ‚ùå Algunos smoke tests fallaron")
            print("   ‚ùå Se requieren correcciones")
            print("   ‚ùå NO procedas hasta resolver todos los problemas")
        
        print(f"\nüîí TU DINERO EST√Å PROTEGIDO:")
        print("   - El sistema NO permitir√° operar sin validaci√≥n completa")
        print("   - Todos los guardrails est√°n activos")
        print("   - Se requiere aprobaci√≥n manual para cambios grandes")
        print("   - Rollback autom√°tico si las m√©tricas empeoran")

def main():
    """Funci√≥n principal"""
    runner = SmokeTestRunner()
    results = runner.run_all_tests()
    runner.generate_report()
    
    # Retornar c√≥digo de salida apropiado
    all_passed = all(results.values())
    exit(0 if all_passed else 1)

if __name__ == "__main__":
    main()
